# Recursion

It is a concept in computer science when a function calls itself and loops until it reaches the desired end condition.

![Screenshot 2024-05-12 143157](https://github.com/Ayush-Patel-1310/Basics-and-DSA/assets/118926325/f50c47e8-defc-4eff-b3ef-5c90f9a9f5c2)

It results in similar behavior to ```for``` or ```while``` loops, except recursion progresses closer to a target condition, while ```for``` loops run a set number of times, and ```while``` loops run until a condition is no longer met.

### Pros

 + Faster when optimized
 + Less code
 + Declarative
 + Efficient Sort and Search

### Cons

 + Maximum recursion depth 
 + Supported, not suggested
 + Uses more memory

```
def printPattern(targetNumber) :
  
  # Base Case
  if (targetNumber <= 0) :
    print(targetNumber)
    return
 
 # Recursive Case
  print(targetNumber)
  printPattern(targetNumber - 5)
  print(targetNumber)
 
# Driver Program 
n = 10
printPattern(n)
```

#### Output:-

```10 5 0 5 10```

## Fibonacci series using recursion

```
def recur_fibo(n):
   # Base Case
   if n <= 1:
       return n
   else:
   # Recursive Case
       return(recur_fibo(n-1) + recur_fibo(n-2))
 
# Driver Code
num = 10
print (recur_fibo(num))
```

Recursion is a powerful technique that has many applications in computer science and programming. Here are some of the common applications of recursion:

 + ```Tree and graph traversal```: Recursion is frequently used for traversing and searching data structures such as trees and graphs. Recursive algorithms can be used to explore all the nodes or vertices of a tree or graph in a systematic way.
 + ```Sorting algorithms```: Recursive algorithms are also used in sorting algorithms such as quicksort and merge sort. These algorithms use recursion to divide the data into smaller subarrays or sublists, sort them, and then merge them back together.
 + ```Divide-and-conquer algorithms```: Many algorithms that use a divide-and-conquer approach, such as the binary search algorithm, use recursion to break down the problem into smaller subproblems.
 + ```Fractal generation```: Fractal shapes and patterns can be generated using recursive algorithms. For example, the Mandelbrot set is generated by repeatedly applying a recursive formula to complex numbers.
 + ```Backtracking algorithms```: Backtracking algorithms are used to solve problems that involve making a sequence of decisions, where each decision depends on the previous ones. These algorithms can be implemented using recursion to explore all possible paths and backtrack when a solution is not found.
 + ```Memoization```: Memoization is a technique that involves storing the results of expensive function calls and returning the cached result when the same inputs occur again. Memoization can be implemented using recursive functions to compute and cache the results of subproblems.

